Go 通常被描述为一种并发友好的语言。 原因是它提供了两种强大机制的简单语法： **协程** 和 **通道**

## 协程
 **协程** 类似于一个线程，但是由 Go 而不是操作系统预定。在 **协程** 中运行的代码可以与其他代码同时运行。我们来看一个例子：


```go
package main

import (
  "fmt"
  "time"
)

func main() {
  fmt.Println("start")
  go process()
  time.Sleep(time.Millisecond * 10) // this is bad, don't do this!
  fmt.Println("done")
}

func process() {
  fmt.Println("processing")
}
```

这里有一些有趣的事情， 但最重要的是我们如何开始一个 **协程** 。 我们只需使用 `go` 关键字，然后使用我们想要执行的函数。如果我们只想运行一部分代码， 如上所述， 我们可以使用匿名函数。需要注意的是，匿名函数不只是可以在 **协程** 中使用，其他地方也可以。

```go
go func() {
  fmt.Println("processing")
}()
```

 **协程** 易于创建且开销很小。最终多个 **协程** 将会在同一个底层的操作系统线程上运行。这通常也称为 M:N 线程模型，因为我们有 M 个应用线程（ **协程** ）运行在 N 个操作系统线程上。结果就是，一个 **协程** 的开销和系统线程比起来相对很低（几KB）。在现代的硬件上，有可能拥有数百万个 **协程** 。

此外，这里还隐藏了映射和调度的复杂性。我们只需要说 *这段代码需要同时并发执行* 然后让 Go 自己去实现它。

如果我们回到我们的例子中，你将会注意到我们使用 `Sleep` 让程序等了几毫秒。这是因为主进程在退出前 **协程** 才会有机会去执行（主进程在退出前不会等待全部 **协程** 执行完毕）。要解决这个问题，我们需要协调我们的代码。